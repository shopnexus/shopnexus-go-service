// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccountAdmin = `-- name: CreateAccountAdmin :one
WITH base AS (
  INSERT INTO "account".base (username, password, role)
  VALUES ($1, $2, 'ADMIN')
  RETURNING id
)
INSERT INTO "account".admin (id)
SELECT id
FROM base
RETURNING id
`

type CreateAccountAdminParams struct {
	Username string
	Password string
}

func (q *Queries) CreateAccountAdmin(ctx context.Context, arg CreateAccountAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountAdmin, arg.Username, arg.Password)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAccountUser = `-- name: CreateAccountUser :one
WITH base AS (
  INSERT INTO "account".base (username, password, role)
  VALUES ($1, $2, 'USER')
  RETURNING id
)
INSERT INTO "account".user (id, email, phone, gender, full_name)
SELECT id, $3, $4, $5, $6
FROM base
RETURNING id
`

type CreateAccountUserParams struct {
	Username string
	Password string
	Email    string
	Phone    string
	Gender   AccountGender
	FullName string
}

func (q *Queries) CreateAccountUser(ctx context.Context, arg CreateAccountUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAccountAdmin = `-- name: GetAccountAdmin :one
SELECT a.id, b.id, b.username, b.password, b.role, b.custom_permission, b.avatar_url
FROM "account".admin a
INNER JOIN "account".base b ON a.id = b.id
WHERE (
  a.id = $1 OR
  b.username = $2
)
`

type GetAccountAdminParams struct {
	ID       pgtype.Int8
	Username pgtype.Text
}

type GetAccountAdminRow struct {
	ID               int64
	ID_2             int64
	Username         string
	Password         string
	Role             string
	CustomPermission pgtype.Bits
	AvatarUrl        pgtype.Text
}

func (q *Queries) GetAccountAdmin(ctx context.Context, arg GetAccountAdminParams) (GetAccountAdminRow, error) {
	row := q.db.QueryRow(ctx, getAccountAdmin, arg.ID, arg.Username)
	var i GetAccountAdminRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.CustomPermission,
		&i.AvatarUrl,
	)
	return i, err
}

const getAccountBase = `-- name: GetAccountBase :one
SELECT id, username, password, role, custom_permission, avatar_url FROM "account".base
WHERE id = $1
`

func (q *Queries) GetAccountBase(ctx context.Context, id int64) (AccountBase, error) {
	row := q.db.QueryRow(ctx, getAccountBase, id)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.CustomPermission,
		&i.AvatarUrl,
	)
	return i, err
}

const getAccountStaff = `-- name: GetAccountStaff :one
SELECT s.id, b.id, b.username, b.password, b.role, b.custom_permission, b.avatar_url
FROM "account".staff s
INNER JOIN "account".base b ON s.id = b.id
WHERE (
  s.id = $1 OR
  b.username = $2
)
`

type GetAccountStaffParams struct {
	ID       pgtype.Int8
	Username pgtype.Text
}

type GetAccountStaffRow struct {
	ID               int64
	ID_2             int64
	Username         string
	Password         string
	Role             string
	CustomPermission pgtype.Bits
	AvatarUrl        pgtype.Text
}

func (q *Queries) GetAccountStaff(ctx context.Context, arg GetAccountStaffParams) (GetAccountStaffRow, error) {
	row := q.db.QueryRow(ctx, getAccountStaff, arg.ID, arg.Username)
	var i GetAccountStaffRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.CustomPermission,
		&i.AvatarUrl,
	)
	return i, err
}

const getAccountUser = `-- name: GetAccountUser :one
SELECT u.id, u.email, u.phone, u.gender, u.full_name, u.default_address_id, b.id, b.username, b.password, b.role, b.custom_permission, b.avatar_url
FROM "account".user u
INNER JOIN "account".base b ON u.id = b.id
WHERE (
  u.id = $1 OR
  u.email = $2 OR
  u.phone = $3 OR
  b.username = $4
)
`

type GetAccountUserParams struct {
	ID       pgtype.Int8
	Email    pgtype.Text
	Phone    pgtype.Text
	Username pgtype.Text
}

type GetAccountUserRow struct {
	ID               int64
	Email            string
	Phone            string
	Gender           AccountGender
	FullName         string
	DefaultAddressID pgtype.Int8
	ID_2             int64
	Username         string
	Password         string
	Role             string
	CustomPermission pgtype.Bits
	AvatarUrl        pgtype.Text
}

func (q *Queries) GetAccountUser(ctx context.Context, arg GetAccountUserParams) (GetAccountUserRow, error) {
	row := q.db.QueryRow(ctx, getAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Username,
	)
	var i GetAccountUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.CustomPermission,
		&i.AvatarUrl,
	)
	return i, err
}

const getCustomPermissions = `-- name: GetCustomPermissions :one
SELECT custom_permission FROM "account".base
WHERE 
id = $1
`

func (q *Queries) GetCustomPermissions(ctx context.Context, id int64) (pgtype.Bits, error) {
	row := q.db.QueryRow(ctx, getCustomPermissions, id)
	var custom_permission pgtype.Bits
	err := row.Scan(&custom_permission)
	return custom_permission, err
}

const getRolePermissions = `-- name: GetRolePermissions :one
SELECT permission FROM "account".permission_on_role
INNER JOIN "account".role ON permission_on_role.role = role.name
WHERE role.name = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, name string) (pgtype.Bits, error) {
	row := q.db.QueryRow(ctx, getRolePermissions, name)
	var permission pgtype.Bits
	err := row.Scan(&permission)
	return permission, err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE "account".base
SET 
  username = COALESCE($2, username),
  password = COALESCE($3, password),
  custom_permission = CASE WHEN $4 = TRUE THEN NULL ELSE COALESCE($5, custom_permission) END,
  avatar_url = COALESCE($6, avatar_url)
WHERE id = $1
RETURNING id, username, password, role, custom_permission, avatar_url
`

type UpdateAccountParams struct {
	ID                   int64
	Username             pgtype.Text
	Password             pgtype.Text
	NullCustomPermission interface{}
	CustomPermission     pgtype.Bits
	AvatarUrl            pgtype.Text
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (AccountBase, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.ID,
		arg.Username,
		arg.Password,
		arg.NullCustomPermission,
		arg.CustomPermission,
		arg.AvatarUrl,
	)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
		&i.CustomPermission,
		&i.AvatarUrl,
	)
	return i, err
}

const updateAccountUser = `-- name: UpdateAccountUser :one
UPDATE "account".user
SET 
  email = COALESCE($2, email),
  phone = COALESCE($3, phone),
  gender = COALESCE($4, gender),
  full_name = COALESCE($5, full_name),
  default_address_id = CASE WHEN $6 = TRUE THEN NULL ELSE COALESCE($7, default_address_id) END
WHERE id = $1
RETURNING id, email, phone, gender, full_name, default_address_id
`

type UpdateAccountUserParams struct {
	ID                   int64
	Email                pgtype.Text
	Phone                pgtype.Text
	Gender               NullAccountGender
	FullName             pgtype.Text
	NullDefaultAddressID interface{}
	DefaultAddressID     pgtype.Int8
}

func (q *Queries) UpdateAccountUser(ctx context.Context, arg UpdateAccountUserParams) (AccountUser, error) {
	row := q.db.QueryRow(ctx, updateAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
		arg.NullDefaultAddressID,
		arg.DefaultAddressID,
	)
	var i AccountUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
	)
	return i, err
}
