// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAdminRole = `-- name: AddAdminRole :exec
INSERT INTO "account".role_on_admin (admin_id, role_id)
VALUES ($1, $2)
ON CONFLICT (admin_id, role_id) DO NOTHING
`

type AddAdminRoleParams struct {
	AdminID int64
	RoleID  string
}

func (q *Queries) AddAdminRole(ctx context.Context, arg AddAdminRoleParams) error {
	_, err := q.db.Exec(ctx, addAdminRole, arg.AdminID, arg.RoleID)
	return err
}

const createAccountAdmin = `-- name: CreateAccountAdmin :one
WITH base AS (
  INSERT INTO "account".base (username, password, type)
  VALUES ($1, $2, 'ADMIN')
  RETURNING id
)
INSERT INTO "account".admin (id)
SELECT id
FROM base
RETURNING id
`

type CreateAccountAdminParams struct {
	Username string
	Password string
}

func (q *Queries) CreateAccountAdmin(ctx context.Context, arg CreateAccountAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountAdmin, arg.Username, arg.Password)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAccountUser = `-- name: CreateAccountUser :one
WITH base AS (
  INSERT INTO "account".base (username, password, type)
  VALUES ($1, $2, 'USER')
  RETURNING id
)
INSERT INTO "account".user (id, email, phone, gender, full_name)
SELECT id, $3, $4, $5, $6
FROM base
RETURNING id
`

type CreateAccountUserParams struct {
	Username string
	Password string
	Email    string
	Phone    string
	Gender   AccountGender
	FullName string
}

func (q *Queries) CreateAccountUser(ctx context.Context, arg CreateAccountUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAccountUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAccountAdmin = `-- name: GetAccountAdmin :one
WITH filtered_roles AS (
  SELECT 
    r.admin_id,
    array_agg(r.role_id) as roles
  FROM "account".role_on_admin r
  WHERE r.admin_id = $1
  GROUP BY r.admin_id
)
SELECT 
  a.id, a.avatar_url, a.is_super_admin,
  b.id, b.username, b.password, b.type,
  COALESCE(r.roles, '{}')::text[] as roles
FROM "account".admin a
INNER JOIN "account".base b ON a.id = b.id
LEFT JOIN filtered_roles r ON r.admin_id = a.id
WHERE (
  a.id = $2 OR
  b.username = $3
)
`

type GetAccountAdminParams struct {
	AdminID  int64
	ID       pgtype.Int8
	Username pgtype.Text
}

type GetAccountAdminRow struct {
	ID           int64
	AvatarUrl    pgtype.Text
	IsSuperAdmin bool
	ID_2         int64
	Username     string
	Password     string
	Type         AccountAccountType
	Roles        []string
}

func (q *Queries) GetAccountAdmin(ctx context.Context, arg GetAccountAdminParams) (GetAccountAdminRow, error) {
	row := q.db.QueryRow(ctx, getAccountAdmin, arg.AdminID, arg.ID, arg.Username)
	var i GetAccountAdminRow
	err := row.Scan(
		&i.ID,
		&i.AvatarUrl,
		&i.IsSuperAdmin,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Type,
		&i.Roles,
	)
	return i, err
}

const getAccountBase = `-- name: GetAccountBase :one
SELECT id, username, password, type FROM "account".base
WHERE id = $1
`

func (q *Queries) GetAccountBase(ctx context.Context, id int64) (AccountBase, error) {
	row := q.db.QueryRow(ctx, getAccountBase, id)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const getAccountUser = `-- name: GetAccountUser :one
SELECT u.id, u.email, u.phone, u.gender, u.full_name, u.default_address_id, u.avatar_url, b.id, b.username, b.password, b.type
FROM "account".user u
INNER JOIN "account".base b ON u.id = b.id
WHERE (
  u.id = $1 OR
  u.email = $2 OR
  u.phone = $3 OR
  b.username = $4
)
`

type GetAccountUserParams struct {
	ID       pgtype.Int8
	Email    pgtype.Text
	Phone    pgtype.Text
	Username pgtype.Text
}

type GetAccountUserRow struct {
	ID               int64
	Email            string
	Phone            string
	Gender           AccountGender
	FullName         string
	DefaultAddressID pgtype.Int8
	AvatarUrl        pgtype.Text
	ID_2             int64
	Username         string
	Password         string
	Type             AccountAccountType
}

func (q *Queries) GetAccountUser(ctx context.Context, arg GetAccountUserParams) (GetAccountUserRow, error) {
	row := q.db.QueryRow(ctx, getAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Username,
	)
	var i GetAccountUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
		&i.AvatarUrl,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const getAdminPermissions = `-- name: GetAdminPermissions :one
SELECT array_agg(DISTINCT p.permission_id)::TEXT[] AS permissions
FROM "account".role_on_admin r
INNER JOIN "account".permission_on_role p ON r.role_id = p.role_id
WHERE r.admin_id = $1
`

func (q *Queries) GetAdminPermissions(ctx context.Context, adminID int64) ([]string, error) {
	row := q.db.QueryRow(ctx, getAdminPermissions, adminID)
	var permissions []string
	err := row.Scan(&permissions)
	return permissions, err
}

const getRolePermissions = `-- name: GetRolePermissions :one
SELECT array_agg(p.permission_id) as permissions
FROM "account".permission_on_role p
INNER JOIN "account".role r ON p.role_id = r.id
WHERE r.id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getRolePermissions, id)
	var permissions interface{}
	err := row.Scan(&permissions)
	return permissions, err
}

const removeAdminRole = `-- name: RemoveAdminRole :exec
DELETE FROM "account".role_on_admin
WHERE admin_id = $1 AND role_id = $2
`

type RemoveAdminRoleParams struct {
	AdminID int64
	RoleID  string
}

func (q *Queries) RemoveAdminRole(ctx context.Context, arg RemoveAdminRoleParams) error {
	_, err := q.db.Exec(ctx, removeAdminRole, arg.AdminID, arg.RoleID)
	return err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE "account".base
SET 
  username = COALESCE($2, username),
  password = COALESCE($3, password)
WHERE id = $1
RETURNING id, username, password, type
`

type UpdateAccountParams struct {
	ID       int64
	Username pgtype.Text
	Password pgtype.Text
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (AccountBase, error) {
	row := q.db.QueryRow(ctx, updateAccount, arg.ID, arg.Username, arg.Password)
	var i AccountBase
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const updateAccountAdmin = `-- name: UpdateAccountAdmin :one
UPDATE "account".admin
SET 
  avatar_url = COALESCE($2, avatar_url)
WHERE id = $1
RETURNING id, avatar_url, is_super_admin
`

type UpdateAccountAdminParams struct {
	ID        int64
	AvatarUrl pgtype.Text
}

func (q *Queries) UpdateAccountAdmin(ctx context.Context, arg UpdateAccountAdminParams) (AccountAdmin, error) {
	row := q.db.QueryRow(ctx, updateAccountAdmin, arg.ID, arg.AvatarUrl)
	var i AccountAdmin
	err := row.Scan(&i.ID, &i.AvatarUrl, &i.IsSuperAdmin)
	return i, err
}

const updateAccountUser = `-- name: UpdateAccountUser :one
UPDATE "account".user
SET 
  email = COALESCE($2, email),
  phone = COALESCE($3, phone),
  gender = COALESCE($4, gender),
  full_name = COALESCE($5, full_name),
  default_address_id = CASE WHEN $6 = TRUE THEN NULL ELSE COALESCE($7, default_address_id) END,
  avatar_url = COALESCE($8, avatar_url)
WHERE id = $1
RETURNING id, email, phone, gender, full_name, default_address_id, avatar_url
`

type UpdateAccountUserParams struct {
	ID                   int64
	Email                pgtype.Text
	Phone                pgtype.Text
	Gender               NullAccountGender
	FullName             pgtype.Text
	NullDefaultAddressID interface{}
	DefaultAddressID     pgtype.Int8
	AvatarUrl            pgtype.Text
}

func (q *Queries) UpdateAccountUser(ctx context.Context, arg UpdateAccountUserParams) (AccountUser, error) {
	row := q.db.QueryRow(ctx, updateAccountUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.FullName,
		arg.NullDefaultAddressID,
		arg.DefaultAddressID,
		arg.AvatarUrl,
	)
	var i AccountUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.FullName,
		&i.DefaultAddressID,
		&i.AvatarUrl,
	)
	return i, err
}
