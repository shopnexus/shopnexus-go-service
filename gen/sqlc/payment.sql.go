// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(p.id)
FROM payment.base p
WHERE (
  (p.user_id = $1 OR $1 IS NULL) AND
  (p.method = $2 OR $2 IS NULL) AND
  (p.status = $3 OR $3 IS NULL) AND
  (p.address ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
  (p.total >= $5 OR $5 IS NULL) AND
  (p.total <= $6 OR $6 IS NULL) AND
  (p.date_created >= $7 OR $7 IS NULL) AND
  (p.date_created <= $8 OR $8 IS NULL)
)
`

type CountPaymentsParams struct {
	UserID          pgtype.Int8
	Method          NullPaymentPaymentMethod
	Status          NullPaymentStatus
	Address         pgtype.Text
	TotalFrom       pgtype.Int8
	TotalTo         pgtype.Int8
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.TotalFrom,
		arg.TotalTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payment.base (
    user_id,
    method,
    status,
    address,
    total
)
VALUES (
    $1, $2, $3, $4, $5
) 
RETURNING id, user_id, method, status, address, total, date_created
`

type CreatePaymentParams struct {
	UserID  int64
	Method  PaymentPaymentMethod
	Status  PaymentStatus
	Address string
	Total   int64
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.Total,
	)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Method,
		&i.Status,
		&i.Address,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

type CreatePaymentProductSerialsParams struct {
	ProductOnPaymentID int64
	ProductSerialID    string
}

type CreatePaymentProductsParams struct {
	PaymentID  int64
	ProductID  int64
	Quantity   int64
	Price      int64
	TotalPrice int64
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payment.base WHERE (
  id = $1 AND
  (user_id = $2 OR $2 IS NULL)
)
`

type DeletePaymentParams struct {
	ID     int64
	UserID pgtype.Int8
}

func (q *Queries) DeletePayment(ctx context.Context, arg DeletePaymentParams) error {
	_, err := q.db.Exec(ctx, deletePayment, arg.ID, arg.UserID)
	return err
}

const existsPayment = `-- name: ExistsPayment :one
SELECT EXISTS (
  SELECT 1
  FROM payment.base p
  WHERE (
    p.id = $1 AND 
    (p.user_id = $2 OR $2 IS NULL) AND 
    (p.status = $3 OR $3 IS NULL)
  )
) AS exists
`

type ExistsPaymentParams struct {
	ID     int64
	UserID pgtype.Int8
	Status NullPaymentStatus
}

func (q *Queries) ExistsPayment(ctx context.Context, arg ExistsPaymentParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsPayment, arg.ID, arg.UserID, arg.Status)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getPayment = `-- name: GetPayment :one
SELECT p.id, p.user_id, p.method, p.status, p.address, p.total, p.date_created
FROM payment.base p
WHERE (
  p.id = $1 AND 
  (p.user_id = $2 OR $2 IS NULL)
)
`

type GetPaymentParams struct {
	ID     int64
	UserID pgtype.Int8
}

func (q *Queries) GetPayment(ctx context.Context, arg GetPaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, getPayment, arg.ID, arg.UserID)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Method,
		&i.Status,
		&i.Address,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

const getPaymentProductSerials = `-- name: GetPaymentProductSerials :many
SELECT ps.serial_id, ps.product_id, ps.is_sold, ps.is_active, ps.date_created, ps.date_updated
FROM payment.product_serial_on_product_on_payment psopop
INNER JOIN product.serial ps ON ps.serial_id = psopop.product_serial_id
WHERE psopop.product_on_payment_id = $1
`

func (q *Queries) GetPaymentProductSerials(ctx context.Context, productOnPaymentID int64) ([]ProductSerial, error) {
	rows, err := q.db.Query(ctx, getPaymentProductSerials, productOnPaymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductSerial
	for rows.Next() {
		var i ProductSerial
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductID,
			&i.IsSold,
			&i.IsActive,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentProducts = `-- name: GetPaymentProducts :many
SELECT pop.id, pop.payment_id, pop.product_id, pop.quantity, pop.price, pop.total_price
FROM payment.product_on_payment pop
WHERE pop.payment_id = $1
`

func (q *Queries) GetPaymentProducts(ctx context.Context, paymentID int64) ([]PaymentProductOnPayment, error) {
	rows, err := q.db.Query(ctx, getPaymentProducts, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentProductOnPayment
	for rows.Next() {
		var i PaymentProductOnPayment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.ProductID,
			&i.Quantity,
			&i.Price,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT p.id, p.user_id, p.method, p.status, p.address, p.total, p.date_created
FROM payment.base p
WHERE (
  (p.user_id = $1 OR $1 IS NULL) AND
  (p.method = $2 OR $2 IS NULL) AND
  (p.status = $3 OR $3 IS NULL) AND
  (p.address ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
  (p.total >= $5 OR $5 IS NULL) AND
  (p.total <= $6 OR $6 IS NULL) AND
  (p.date_created >= $7 OR $7 IS NULL) AND
  (p.date_created <= $8 OR $8 IS NULL)
)
ORDER BY p.date_created DESC
LIMIT $10
OFFSET $9
`

type ListPaymentsParams struct {
	UserID          pgtype.Int8
	Method          NullPaymentPaymentMethod
	Status          NullPaymentStatus
	Address         pgtype.Text
	TotalFrom       pgtype.Int8
	TotalTo         pgtype.Int8
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
	Offset          int32
	Limit           int32
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]PaymentBase, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.UserID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.TotalFrom,
		arg.TotalTo,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentBase
	for rows.Next() {
		var i PaymentBase
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Method,
			&i.Status,
			&i.Address,
			&i.Total,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :exec
UPDATE payment.base
SET 
    method = COALESCE($2, method),
    status = COALESCE($3, status),
    address = COALESCE($4, address),
    total = COALESCE($5, total)
WHERE (
  id = $1 AND
  (user_id = $6 OR $6 IS NULL)
)
`

type UpdatePaymentParams struct {
	ID      int64
	Method  NullPaymentPaymentMethod
	Status  NullPaymentStatus
	Address pgtype.Text
	Total   pgtype.Int8
	UserID  pgtype.Int8
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) error {
	_, err := q.db.Exec(ctx, updatePayment,
		arg.ID,
		arg.Method,
		arg.Status,
		arg.Address,
		arg.Total,
		arg.UserID,
	)
	return err
}
