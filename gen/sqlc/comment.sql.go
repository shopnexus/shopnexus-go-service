// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comment.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countComments = `-- name: CountComments :one
SELECT COUNT(id) FROM product.comment
WHERE
    (account_id = $1 OR $1 IS NULL) AND
    (dest_id = $2 OR $2 IS NULL) AND
    ($3 ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
    (upvote >= $4 OR $4 IS NULL) AND
    (upvote <= $5 OR $5 IS NULL) AND
    (downvote >= $6 OR $6 IS NULL) AND
    (downvote <= $7 OR $7 IS NULL) AND
    (score >= $8 OR $8 IS NULL) AND
    (score <= $9 OR $9 IS NULL) AND
    (date_created >= $10 OR $10 IS NULL) AND
    (date_created <= $11 OR $11 IS NULL)
`

type CountCommentsParams struct {
	AccountID     pgtype.Int8
	DestID        pgtype.Int8
	Body          interface{}
	UpvoteFrom    pgtype.Int8
	UpvoteTo      pgtype.Int8
	DownvoteFrom  pgtype.Int8
	DownvoteTo    pgtype.Int8
	ScoreFrom     pgtype.Int4
	ScoreTo       pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
}

func (q *Queries) CountComments(ctx context.Context, arg CountCommentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countComments,
		arg.AccountID,
		arg.DestID,
		arg.Body,
		arg.UpvoteFrom,
		arg.UpvoteTo,
		arg.DownvoteFrom,
		arg.DownvoteTo,
		arg.ScoreFrom,
		arg.ScoreTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComment = `-- name: CreateComment :exec
INSERT INTO product.comment (
    account_id, dest_id, body, upvote, downvote, score
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateCommentParams struct {
	AccountID int64
	DestID    int64
	Body      string
	Upvote    int64
	Downvote  int64
	Score     int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) error {
	_, err := q.db.Exec(ctx, createComment,
		arg.AccountID,
		arg.DestID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
	)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM product.comment 
WHERE (
  id = $1
  AND (account_id = $2 OR $2 IS NULL)
)
`

type DeleteCommentParams struct {
	ID        int64
	AccountID pgtype.Int8
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.AccountID)
	return err
}

const getComment = `-- name: GetComment :one
SELECT 
    c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated,
    COALESCE(array_agg(DISTINCT res.url) FILTER (WHERE res.url IS NOT NULL), '{}')::text[] as resources
FROM product.comment c
LEFT JOIN product.resource res ON c.id = res.owner_id
WHERE id = $1
GROUP BY c.id
`

type GetCommentRow struct {
	ID          int64
	Type        ProductCommentType
	AccountID   int64
	DestID      int64
	Body        string
	Upvote      int64
	Downvote    int64
	Score       int32
	DateCreated pgtype.Timestamptz
	DateUpdated pgtype.Timestamptz
	Resources   []string
}

func (q *Queries) GetComment(ctx context.Context, id int64) (GetCommentRow, error) {
	row := q.db.QueryRow(ctx, getComment, id)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AccountID,
		&i.DestID,
		&i.Body,
		&i.Upvote,
		&i.Downvote,
		&i.Score,
		&i.DateCreated,
		&i.DateUpdated,
		&i.Resources,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
SELECT 
    c.id, c.type, c.account_id, c.dest_id, c.body, c.upvote, c.downvote, c.score, c.date_created, c.date_updated,
    COALESCE(array_agg(DISTINCT res.url) FILTER (WHERE res.url IS NOT NULL), '{}')::text[] as resources
FROM product.comment c
LEFT JOIN product.resource res ON c.id = res.owner_id
WHERE
    (account_id = $1 OR $1 IS NULL) AND
    (dest_id = $2 OR $2 IS NULL) AND
    ($3 ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
    (upvote >= $4 OR $4 IS NULL) AND
    (upvote <= $5 OR $5 IS NULL) AND
    (downvote >= $6 OR $6 IS NULL) AND
    (downvote <= $7 OR $7 IS NULL) AND
    (score >= $8 OR $8 IS NULL) AND
    (score <= $9 OR $9 IS NULL) AND
    (date_created >= $10 OR $10 IS NULL) AND
    (date_created <= $11 OR $11 IS NULL)
GROUP BY c.id
ORDER BY date_created DESC
LIMIT $13
OFFSET $12
`

type ListCommentsParams struct {
	AccountID     pgtype.Int8
	DestID        pgtype.Int8
	Body          interface{}
	UpvoteFrom    pgtype.Int8
	UpvoteTo      pgtype.Int8
	DownvoteFrom  pgtype.Int8
	DownvoteTo    pgtype.Int8
	ScoreFrom     pgtype.Int4
	ScoreTo       pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

type ListCommentsRow struct {
	ID          int64
	Type        ProductCommentType
	AccountID   int64
	DestID      int64
	Body        string
	Upvote      int64
	Downvote    int64
	Score       int32
	DateCreated pgtype.Timestamptz
	DateUpdated pgtype.Timestamptz
	Resources   []string
}

func (q *Queries) ListComments(ctx context.Context, arg ListCommentsParams) ([]ListCommentsRow, error) {
	rows, err := q.db.Query(ctx, listComments,
		arg.AccountID,
		arg.DestID,
		arg.Body,
		arg.UpvoteFrom,
		arg.UpvoteTo,
		arg.DownvoteFrom,
		arg.DownvoteTo,
		arg.ScoreFrom,
		arg.ScoreTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentsRow
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.AccountID,
			&i.DestID,
			&i.Body,
			&i.Upvote,
			&i.Downvote,
			&i.Score,
			&i.DateCreated,
			&i.DateUpdated,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE product.comment
SET 
    body = COALESCE($2, body),
    upvote = COALESCE($3, upvote),
    downvote = COALESCE($4, downvote),
    score = COALESCE($5, score)
WHERE 
    id = $1 AND 
    (account_id = $6 OR $6 IS NULL)
`

type UpdateCommentParams struct {
	ID        int64
	Body      pgtype.Text
	Upvote    pgtype.Int8
	Downvote  pgtype.Int8
	Score     pgtype.Int4
	AccountID pgtype.Int8
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment,
		arg.ID,
		arg.Body,
		arg.Upvote,
		arg.Downvote,
		arg.Score,
		arg.AccountID,
	)
	return err
}
