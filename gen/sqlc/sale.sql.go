// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sale.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSales = `-- name: CountSales :one
SELECT COUNT(*) FROM product.sale
WHERE
    ($1::text IS NULL OR tag = $1) AND
    ($2::bigint IS NULL OR product_model_id = $2) AND
    ($3::bigint IS NULL OR brand_id = $3) AND
    ($4::timestamptz IS NULL OR date_started >= $4) AND
    ($5::timestamptz IS NULL OR date_started <= $5) AND
    ($6::timestamptz IS NULL OR date_ended >= $6) AND
    ($7::timestamptz IS NULL OR date_ended <= $7) AND
    ($8::boolean IS NULL OR is_active = $8)
`

type CountSalesParams struct {
	Tag             pgtype.Text
	ProductModelID  pgtype.Int8
	BrandID         pgtype.Int8
	DateStartedFrom pgtype.Timestamptz
	DateStartedTo   pgtype.Timestamptz
	DateEndedFrom   pgtype.Timestamptz
	DateEndedTo     pgtype.Timestamptz
	IsActive        pgtype.Bool
}

func (q *Queries) CountSales(ctx context.Context, arg CountSalesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSales,
		arg.Tag,
		arg.ProductModelID,
		arg.BrandID,
		arg.DateStartedFrom,
		arg.DateStartedTo,
		arg.DateEndedFrom,
		arg.DateEndedTo,
		arg.IsActive,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSale = `-- name: CreateSale :one
INSERT INTO product.sale (
    tag,
    product_model_id,
    brand_id,
    date_started,
    date_ended,
    quantity,
    used,
    is_active,
    discount_percent,
    discount_price,
    max_discount_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tag, product_model_id, brand_id, date_created, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price, max_discount_price
`

type CreateSaleParams struct {
	Tag              pgtype.Text
	ProductModelID   pgtype.Int8
	BrandID          pgtype.Int8
	DateStarted      pgtype.Timestamptz
	DateEnded        pgtype.Timestamptz
	Quantity         int64
	Used             int64
	IsActive         bool
	DiscountPercent  pgtype.Int4
	DiscountPrice    pgtype.Int8
	MaxDiscountPrice int64
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (ProductSale, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.Tag,
		arg.ProductModelID,
		arg.BrandID,
		arg.DateStarted,
		arg.DateEnded,
		arg.Quantity,
		arg.Used,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
		arg.MaxDiscountPrice,
	)
	var i ProductSale
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.ProductModelID,
		&i.BrandID,
		&i.DateCreated,
		&i.DateStarted,
		&i.DateEnded,
		&i.Quantity,
		&i.Used,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
		&i.MaxDiscountPrice,
	)
	return i, err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM product.sale WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSale, id)
	return err
}

const getAvailableSales = `-- name: GetAvailableSales :many
SELECT id, tag, product_model_id, brand_id, date_created, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price, max_discount_price FROM product.sale
WHERE 
    is_active = true AND
    used < quantity AND
    date_started <= CURRENT_TIMESTAMP AND
    (date_ended IS NULL OR date_ended >= CURRENT_TIMESTAMP) AND
    (
        (product_model_id = $1::bigint) OR
        (brand_id = $2::bigint) OR
        (tag = ANY($3::text[]))
    )
`

type GetAvailableSalesParams struct {
	ProductModelID int64
	BrandID        int64
	Tags           []string
}

func (q *Queries) GetAvailableSales(ctx context.Context, arg GetAvailableSalesParams) ([]ProductSale, error) {
	rows, err := q.db.Query(ctx, getAvailableSales, arg.ProductModelID, arg.BrandID, arg.Tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductSale
	for rows.Next() {
		var i ProductSale
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.ProductModelID,
			&i.BrandID,
			&i.DateCreated,
			&i.DateStarted,
			&i.DateEnded,
			&i.Quantity,
			&i.Used,
			&i.IsActive,
			&i.DiscountPercent,
			&i.DiscountPrice,
			&i.MaxDiscountPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSale = `-- name: GetSale :one
SELECT id, tag, product_model_id, brand_id, date_created, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price, max_discount_price FROM product.sale WHERE id = $1
`

func (q *Queries) GetSale(ctx context.Context, id int64) (ProductSale, error) {
	row := q.db.QueryRow(ctx, getSale, id)
	var i ProductSale
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.ProductModelID,
		&i.BrandID,
		&i.DateCreated,
		&i.DateStarted,
		&i.DateEnded,
		&i.Quantity,
		&i.Used,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
		&i.MaxDiscountPrice,
	)
	return i, err
}

const listSales = `-- name: ListSales :many
SELECT id, tag, product_model_id, brand_id, date_created, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price, max_discount_price FROM product.sale
WHERE
    ($1::text IS NULL OR tag = $1) AND
    ($2::bigint IS NULL OR product_model_id = $2) AND
    ($3::bigint IS NULL OR brand_id = $3) AND
    ($4::timestamptz IS NULL OR date_started >= $4) AND
    ($5::timestamptz IS NULL OR date_started <= $5) AND
    ($6::timestamptz IS NULL OR date_ended >= $6) AND
    ($7::timestamptz IS NULL OR date_ended <= $7) AND
    ($8::boolean IS NULL OR is_active = $8)
ORDER BY id
LIMIT $10
OFFSET $9
`

type ListSalesParams struct {
	Tag             pgtype.Text
	ProductModelID  pgtype.Int8
	BrandID         pgtype.Int8
	DateStartedFrom pgtype.Timestamptz
	DateStartedTo   pgtype.Timestamptz
	DateEndedFrom   pgtype.Timestamptz
	DateEndedTo     pgtype.Timestamptz
	IsActive        pgtype.Bool
	Offset          int32
	Limit           int32
}

func (q *Queries) ListSales(ctx context.Context, arg ListSalesParams) ([]ProductSale, error) {
	rows, err := q.db.Query(ctx, listSales,
		arg.Tag,
		arg.ProductModelID,
		arg.BrandID,
		arg.DateStartedFrom,
		arg.DateStartedTo,
		arg.DateEndedFrom,
		arg.DateEndedTo,
		arg.IsActive,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductSale
	for rows.Next() {
		var i ProductSale
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.ProductModelID,
			&i.BrandID,
			&i.DateCreated,
			&i.DateStarted,
			&i.DateEnded,
			&i.Quantity,
			&i.Used,
			&i.IsActive,
			&i.DiscountPercent,
			&i.DiscountPrice,
			&i.MaxDiscountPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSale = `-- name: UpdateSale :exec
UPDATE product.sale
SET
    tag = COALESCE($2, tag),
    product_model_id = COALESCE($3, product_model_id),
    brand_id = COALESCE($4, brand_id),
    date_started = COALESCE($5, date_started),
    date_ended = COALESCE($6, date_ended),
    quantity = COALESCE($7, quantity),
    used = COALESCE($8, used),
    is_active = COALESCE($9, is_active),
    discount_percent = COALESCE($10, discount_percent),
    discount_price = COALESCE($11, discount_price),
    max_discount_price = COALESCE($12, max_discount_price)
WHERE id = $1
`

type UpdateSaleParams struct {
	ID               int64
	Tag              pgtype.Text
	ProductModelID   pgtype.Int8
	BrandID          pgtype.Int8
	DateStarted      pgtype.Timestamptz
	DateEnded        pgtype.Timestamptz
	Quantity         pgtype.Int8
	Used             pgtype.Int8
	IsActive         pgtype.Bool
	DiscountPercent  pgtype.Int4
	DiscountPrice    pgtype.Int8
	MaxDiscountPrice pgtype.Int8
}

func (q *Queries) UpdateSale(ctx context.Context, arg UpdateSaleParams) error {
	_, err := q.db.Exec(ctx, updateSale,
		arg.ID,
		arg.Tag,
		arg.ProductModelID,
		arg.BrandID,
		arg.DateStarted,
		arg.DateEnded,
		arg.Quantity,
		arg.Used,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
		arg.MaxDiscountPrice,
	)
	return err
}
