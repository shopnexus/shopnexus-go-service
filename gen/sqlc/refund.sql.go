// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: refund.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRefunds = `-- name: CountRefunds :one
SELECT COUNT(id)
FROM payment.refund r
INNER JOIN payment.base p ON r.payment_id = p.id
WHERE (
    (p.user_id = $1 OR $1 IS NULL) AND
    (r.payment_id = $2 OR $2 IS NULL) AND
    (r.method = $3 OR $3 IS NULL) AND
    (r.status = $4 OR $4 IS NULL) AND
    (r.reason ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
    (r.address ILIKE '%' || $6 || '%' OR $6 IS NULL) AND
    (r.date_created >= $7 OR $7 IS NULL) AND
    (r.date_created <= $8 OR $8 IS NULL)
)
`

type CountRefundsParams struct {
	UserID          pgtype.Int8
	PaymentID       pgtype.Int8
	Method          NullPaymentRefundMethod
	Status          NullPaymentStatus
	Reason          pgtype.Text
	Address         pgtype.Text
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
}

func (q *Queries) CountRefunds(ctx context.Context, arg CountRefundsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRefunds,
		arg.UserID,
		arg.PaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefund = `-- name: CreateRefund :one
WITH inserted_refund AS (
    INSERT INTO payment.refund (
        payment_id,
        method,
        status,
        reason,
        address
    )
    VALUES (
        $1, $2, $3, $4, $5
    )
    RETURNING id, payment_id, method, status, reason, address, date_created, date_updated
),
inserted_resources AS (
    INSERT INTO product.resource (owner_id, s3_id)
    SELECT id, unnest($6::text[]) FROM inserted_refund
    RETURNING s3_id
)
SELECT r.id, COALESCE(array_agg(res.s3_id), '{}')::text[] as resources
FROM inserted_refund r
LEFT JOIN inserted_resources res ON true
GROUP BY r.id
`

type CreateRefundParams struct {
	PaymentID int64
	Method    PaymentRefundMethod
	Status    PaymentStatus
	Reason    string
	Address   string
	Resources []string
}

type CreateRefundRow struct {
	ID        int64
	Resources []string
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (CreateRefundRow, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.PaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.Resources,
	)
	var i CreateRefundRow
	err := row.Scan(&i.ID, &i.Resources)
	return i, err
}

const deleteRefund = `-- name: DeleteRefund :exec


DELETE FROM payment.refund WHERE id = $1
`

func (q *Queries) DeleteRefund(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRefund, id)
	return err
}

const existsRefund = `-- name: ExistsRefund :one
SELECT EXISTS (
  SELECT 1
  FROM payment.refund r
  INNER JOIN payment.base p ON r.payment_id = p.id
  WHERE (
    r.id = $1 AND 
    (p.user_id = $2 OR $2 IS NULL)
  )
) AS exists
`

type ExistsRefundParams struct {
	ID     int64
	UserID pgtype.Int8
}

func (q *Queries) ExistsRefund(ctx context.Context, arg ExistsRefundParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsRefund, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getRefund = `-- name: GetRefund :one
SELECT 
  r.id, r.payment_id, r.method, r.status, r.reason, r.address, r.date_created, r.date_updated,
  COALESCE(array_agg(res.s3_id), '{}')::text[] AS resources
FROM payment.refund r
LEFT JOIN product.resource res ON r.id = res.owner_id
WHERE (
  r.id = $1 AND (
    $2 IS NULL OR r.user_id = $2
  )
)
GROUP BY r.id
`

type GetRefundParams struct {
	ID     int64
	UserID interface{}
}

type GetRefundRow struct {
	ID          int64
	PaymentID   int64
	Method      PaymentRefundMethod
	Status      PaymentStatus
	Reason      string
	Address     string
	DateCreated pgtype.Timestamptz
	DateUpdated pgtype.Timestamptz
	Resources   []string
}

func (q *Queries) GetRefund(ctx context.Context, arg GetRefundParams) (GetRefundRow, error) {
	row := q.db.QueryRow(ctx, getRefund, arg.ID, arg.UserID)
	var i GetRefundRow
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Method,
		&i.Status,
		&i.Reason,
		&i.Address,
		&i.DateCreated,
		&i.DateUpdated,
		&i.Resources,
	)
	return i, err
}

const listRefunds = `-- name: ListRefunds :many
SELECT 
    r.id, r.payment_id, r.method, r.status, r.reason, r.address, r.date_created, r.date_updated,
    COALESCE(array_agg(res.s3_id), '{}')::text[] as resources
FROM payment.refund r
LEFT JOIN product.resource res ON res.owner_id = r.id
INNER JOIN payment.base p ON r.payment_id = p.id
WHERE (
    (p.user_id = $1 OR $1 IS NULL) AND
    (r.payment_id = $2 OR $2 IS NULL) AND
    (r.method = $3 OR $3 IS NULL) AND
    (r.status = $4 OR $4 IS NULL) AND
    (r.reason ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
    (r.address ILIKE '%' || $6 || '%' OR $6 IS NULL) AND
    (r.date_created >= $7 OR $7 IS NULL) AND
    (r.date_created <= $8 OR $8 IS NULL)
)
ORDER BY r.date_created DESC
LIMIT $10
OFFSET $9
`

type ListRefundsParams struct {
	UserID          pgtype.Int8
	PaymentID       pgtype.Int8
	Method          NullPaymentRefundMethod
	Status          NullPaymentStatus
	Reason          pgtype.Text
	Address         pgtype.Text
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
	Offset          int32
	Limit           int32
}

type ListRefundsRow struct {
	ID          int64
	PaymentID   int64
	Method      PaymentRefundMethod
	Status      PaymentStatus
	Reason      string
	Address     string
	DateCreated pgtype.Timestamptz
	DateUpdated pgtype.Timestamptz
	Resources   []string
}

func (q *Queries) ListRefunds(ctx context.Context, arg ListRefundsParams) ([]ListRefundsRow, error) {
	rows, err := q.db.Query(ctx, listRefunds,
		arg.UserID,
		arg.PaymentID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRefundsRow
	for rows.Next() {
		var i ListRefundsRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Method,
			&i.Status,
			&i.Reason,
			&i.Address,
			&i.DateCreated,
			&i.DateUpdated,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefund = `-- name: UpdateRefund :exec
UPDATE payment.refund
SET 
    method = COALESCE($2, method),
    status = COALESCE($3, status),
    reason = COALESCE($4, reason),
    address = COALESCE($5, address)
WHERE id = $1
`

type UpdateRefundParams struct {
	ID      int64
	Method  NullPaymentRefundMethod
	Status  NullPaymentStatus
	Reason  pgtype.Text
	Address pgtype.Text
}

func (q *Queries) UpdateRefund(ctx context.Context, arg UpdateRefundParams) error {
	_, err := q.db.Exec(ctx, updateRefund,
		arg.ID,
		arg.Method,
		arg.Status,
		arg.Reason,
		arg.Address,
	)
	return err
}
