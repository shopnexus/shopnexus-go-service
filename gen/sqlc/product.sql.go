// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBrand = `-- name: CreateBrand :one
WITH inserted_brand AS (
    INSERT INTO product.brand (id, name, description)
    VALUES ($1, $2, $3)
    RETURNING id, name, description
),
inserted_images AS (
    INSERT INTO product.image (brand_id, url)
    SELECT $1, unnest($4::text[])
    RETURNING url
)
SELECT 
    b.id,
    b.name,
    b.description,
    COALESCE(array_agg(i.url), '{}') as images
FROM inserted_brand b
LEFT JOIN inserted_images i ON true
GROUP BY b.id
`

type CreateBrandParams struct {
	ID          []byte
	Name        string
	Description string
	Column4     []string
}

type CreateBrandRow struct {
	ID          []byte
	Name        string
	Description string
	Images      interface{}
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (CreateBrandRow, error) {
	row := q.db.QueryRow(ctx, createBrand,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Column4,
	)
	var i CreateBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Images,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product.base (
    serial_id,
    product_model_id,
    date_created,
    date_update
) VALUES (
    $1, $2, NOW(), NOW()
) RETURNING 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
`

type CreateProductParams struct {
	SerialID       []byte
	ProductModelID []byte
}

type CreateProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (CreateProductRow, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.SerialID, arg.ProductModelID)
	var i CreateProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const createProductModel = `-- name: CreateProductModel :one
WITH inserted_model AS (
    INSERT INTO product.model (
        id, brand_id, name, description, list_price, date_manufactured
    ) VALUES (
        $1, $2, $3, $4, $5, $6
    ) RETURNING id, brand_id, name, description, list_price, date_manufactured
),
inserted_images AS (
    INSERT INTO product.image (product_model_id, url)
    SELECT $1, unnest($7::text[])
    RETURNING url
),
inserted_tags AS (
    INSERT INTO product.tag_on_product (product_model_id, tag_name)
    SELECT $1, unnest($8::text[])
    RETURNING tag_name
)
SELECT 
    m.id,
    m.brand_id,
    m.name,
    m.description,
    m.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM inserted_model m
LEFT JOIN inserted_images i ON true
LEFT JOIN inserted_tags t ON true
GROUP BY m.id
`

type CreateProductModelParams struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Column7          []string
	Column8          []string
}

type CreateProductModelRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) CreateProductModel(ctx context.Context, arg CreateProductModelParams) (CreateProductModelRow, error) {
	row := q.db.QueryRow(ctx, createProductModel,
		arg.ID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.ListPrice,
		arg.DateManufactured,
		arg.Column7,
		arg.Column8,
	)
	var i CreateProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.Images,
		&i.Tags,
	)
	return i, err
}

const createSale = `-- name: CreateSale :one
INSERT INTO product.sale (
    id,
    tag_name,
    product_model_id,
    date_started,
    date_ended,
    quantity,
    used,
    is_active,
    discount_percent,
    discount_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tag_name, product_model_id, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price
`

type CreateSaleParams struct {
	ID              []byte
	TagName         pgtype.Text
	ProductModelID  []byte
	DateStarted     pgtype.Timestamp
	DateEnded       pgtype.Timestamp
	Quantity        int64
	Used            int64
	IsActive        bool
	DiscountPercent pgtype.Int4
	DiscountPrice   pgtype.Numeric
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (ProductSale, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.ID,
		arg.TagName,
		arg.ProductModelID,
		arg.DateStarted,
		arg.DateEnded,
		arg.Quantity,
		arg.Used,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
	)
	var i ProductSale
	err := row.Scan(
		&i.ID,
		&i.TagName,
		&i.ProductModelID,
		&i.DateStarted,
		&i.DateEnded,
		&i.Quantity,
		&i.Used,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO product.tag (
    tag_name,
    description
) VALUES (
    $1, $2
) RETURNING tag_name, description
`

type CreateTagParams struct {
	TagName     string
	Description pgtype.Text
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (ProductTag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.TagName, arg.Description)
	var i ProductTag
	err := row.Scan(&i.TagName, &i.Description)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM product.brand WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteBrand, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM product.base WHERE serial_id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, serialID []byte) error {
	_, err := q.db.Exec(ctx, deleteProduct, serialID)
	return err
}

const deleteProductModel = `-- name: DeleteProductModel :exec
DELETE FROM product.model WHERE id = $1
`

func (q *Queries) DeleteProductModel(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteProductModel, id)
	return err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM product.sale WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteSale, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM product.tag WHERE tag_name = $1
`

func (q *Queries) DeleteTag(ctx context.Context, tagName string) error {
	_, err := q.db.Exec(ctx, deleteTag, tagName)
	return err
}

const getBrand = `-- name: GetBrand :one
SELECT 
    b.id,
    b.name,
    b.description,
    COALESCE(array_agg(i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images
FROM product.brand b
LEFT JOIN product.image i ON i.brand_id = b.id
WHERE b.id = $1
GROUP BY b.id
`

type GetBrandRow struct {
	ID          []byte
	Name        string
	Description string
	Images      interface{}
}

func (q *Queries) GetBrand(ctx context.Context, id []byte) (GetBrandRow, error) {
	row := q.db.QueryRow(ctx, getBrand, id)
	var i GetBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Images,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
FROM product.base
WHERE serial_id = $1
`

type GetProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) GetProduct(ctx context.Context, serialID []byte) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, serialID)
	var i GetProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const getProductModel = `-- name: GetProductModel :one
SELECT 
    pm.id,
    pm.brand_id,
    pm.name,
    pm.description,
    pm.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM product.model pm
LEFT JOIN product.image i ON i.product_model_id = pm.id
LEFT JOIN product.tag_on_product t ON t.product_model_id = pm.id
WHERE pm.id = $1
GROUP BY pm.id
`

type GetProductModelRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) GetProductModel(ctx context.Context, id []byte) (GetProductModelRow, error) {
	row := q.db.QueryRow(ctx, getProductModel, id)
	var i GetProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.Images,
		&i.Tags,
	)
	return i, err
}

const listBrands = `-- name: ListBrands :many
SELECT 
    b.id,
    b.name,
    b.description,
    COALESCE(array_agg(i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images
FROM product.brand b
LEFT JOIN product.image i ON i.brand_id = b.id
WHERE ($1::text IS NULL OR b.name ILIKE '%' || $1 || '%')
    AND ($2::text IS NULL OR b.description ILIKE '%' || $2 || '%')
GROUP BY b.id
ORDER BY b.name
LIMIT $3 OFFSET $4
`

type ListBrandsParams struct {
	Column1 string
	Column2 string
	Limit   int32
	Offset  int32
}

type ListBrandsRow struct {
	ID          []byte
	Name        string
	Description string
	Images      interface{}
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]ListBrandsRow, error) {
	rows, err := q.db.Query(ctx, listBrands,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBrandsRow
	for rows.Next() {
		var i ListBrandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductModels = `-- name: ListProductModels :many
SELECT 
    pm.id,
    pm.brand_id,
    pm.name,
    pm.description,
    pm.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM product.model pm
LEFT JOIN product.image i ON i.product_model_id = pm.id
LEFT JOIN product.tag_on_product t ON t.product_model_id = pm.id
WHERE ($1::bytea IS NULL OR pm.brand_id = $1)
    AND ($2::text IS NULL OR pm.name ILIKE '%' || $2 || '%')
    AND ($3::text IS NULL OR pm.description ILIKE '%' || $3 || '%')
    AND ($4::decimal IS NULL OR pm.list_price = $4)
    AND ($5::timestamp IS NULL OR pm.date_manufactured >= $5)
    AND ($6::timestamp IS NULL OR pm.date_manufactured <= $6)
GROUP BY pm.id
ORDER BY pm.name
LIMIT $7 OFFSET $8
`

type ListProductModelsParams struct {
	Column1 []byte
	Column2 string
	Column3 string
	Column4 pgtype.Numeric
	Column5 pgtype.Timestamp
	Column6 pgtype.Timestamp
	Limit   int32
	Offset  int32
}

type ListProductModelsRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) ListProductModels(ctx context.Context, arg ListProductModelsParams) ([]ListProductModelsRow, error) {
	rows, err := q.db.Query(ctx, listProductModels,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductModelsRow
	for rows.Next() {
		var i ListProductModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.Name,
			&i.Description,
			&i.ListPrice,
			&i.Images,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
FROM product.base
WHERE ($1::bytea IS NULL OR product_model_id = $1)
    AND ($2::timestamp IS NULL OR date_created >= $2)
    AND ($3::timestamp IS NULL OR date_created <= $3)
ORDER BY date_created DESC
LIMIT $4 OFFSET $5
`

type ListProductsParams struct {
	Column1 []byte
	Column2 pgtype.Timestamp
	Column3 pgtype.Timestamp
	Limit   int32
	Offset  int32
}

type ListProductsRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductModelID,
			&i.DateCreated,
			&i.DateUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :one
WITH updated_brand AS (
    UPDATE product.brand
    SET name = $2,
        description = $3
    WHERE id = $1
    RETURNING id, name, description
),
deleted_images AS (
    DELETE FROM product.image
    WHERE brand_id = $1
),
inserted_images AS (
    INSERT INTO product.image (brand_id, url)
    SELECT $1, unnest($4::text[])
    RETURNING url
)
SELECT 
    b.id,
    b.name,
    b.description,
    COALESCE(array_agg(i.url), '{}') as images
FROM updated_brand b
LEFT JOIN inserted_images i ON true
GROUP BY b.id
`

type UpdateBrandParams struct {
	ID          []byte
	Name        string
	Description string
	Column4     []string
}

type UpdateBrandRow struct {
	ID          []byte
	Name        string
	Description string
	Images      interface{}
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (UpdateBrandRow, error) {
	row := q.db.QueryRow(ctx, updateBrand,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Column4,
	)
	var i UpdateBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Images,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE product.base
SET 
    product_model_id = $2,
    date_update = NOW()
WHERE serial_id = $1
RETURNING 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
`

type UpdateProductParams struct {
	SerialID       []byte
	ProductModelID []byte
}

type UpdateProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (UpdateProductRow, error) {
	row := q.db.QueryRow(ctx, updateProduct, arg.SerialID, arg.ProductModelID)
	var i UpdateProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const updateProductModel = `-- name: UpdateProductModel :one
WITH updated_model AS (
    UPDATE product.model
    SET brand_id = $2,
        name = $3,
        description = $4,
        list_price = $5,
        date_manufactured = $6
    WHERE id = $1
    RETURNING id, brand_id, name, description, list_price, date_manufactured
),
deleted_images AS (
    DELETE FROM product.image
    WHERE product_model_id = $1
),
deleted_tags AS (
    DELETE FROM product.tag_on_product
    WHERE product_model_id = $1
),
inserted_images AS (
    INSERT INTO product.image (product_model_id, url)
    SELECT $1, unnest($7::text[])
    RETURNING url
),
inserted_tags AS (
    INSERT INTO product.tag_on_product (product_model_id, tag_name)
    SELECT $1, unnest($8::text[])
    RETURNING tag_name
)
SELECT 
    m.id,
    m.brand_id,
    m.name,
    m.description,
    m.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM updated_model m
LEFT JOIN inserted_images i ON true
LEFT JOIN inserted_tags t ON true
GROUP BY m.id
`

type UpdateProductModelParams struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Column7          []string
	Column8          []string
}

type UpdateProductModelRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) UpdateProductModel(ctx context.Context, arg UpdateProductModelParams) (UpdateProductModelRow, error) {
	row := q.db.QueryRow(ctx, updateProductModel,
		arg.ID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.ListPrice,
		arg.DateManufactured,
		arg.Column7,
		arg.Column8,
	)
	var i UpdateProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.Images,
		&i.Tags,
	)
	return i, err
}
