// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBrands = `-- name: CountBrands :one
WITH filtered_brands AS (
  SELECT b.id
  FROM product.brand b
  WHERE (
    (name ILIKE $1 OR $1 IS NULL) AND
    (description ILIKE $2 OR $2 IS NULL)
  )
)
SELECT COUNT(id)
FROM filtered_brands
`

type CountBrandsParams struct {
	Name        pgtype.Text
	Description pgtype.Text
}

func (q *Queries) CountBrands(ctx context.Context, arg CountBrandsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBrands, arg.Name, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrand = `-- name: CreateBrand :one
WITH inserted_brand AS (
    INSERT INTO product.brand (id, name, description)
    VALUES ($1, $2, $3)
    RETURNING id, name, description
),
inserted_images AS (
    INSERT INTO product.image (brand_id, url)
    SELECT $1, unnest($4::text[])
    RETURNING url
)
SELECT 
    b.id, b.name, b.description,
    COALESCE(array_agg(i.url), '{}') as images
FROM inserted_brand b
LEFT JOIN inserted_images i ON true
GROUP BY b.id
`

type CreateBrandParams struct {
	ID          []byte
	Name        string
	Description string
	Images      []string
}

type CreateBrandRow struct {
	ID          []byte
	Name        string
	Description string
	Images      interface{}
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (CreateBrandRow, error) {
	row := q.db.QueryRow(ctx, createBrand,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Images,
	)
	var i CreateBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Images,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product.base (
    serial_id,
    product_model_id,
    date_created,
    date_update
) VALUES (
    $1, $2, NOW(), NOW()
) RETURNING 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
`

type CreateProductParams struct {
	SerialID       []byte
	ProductModelID []byte
}

type CreateProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (CreateProductRow, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.SerialID, arg.ProductModelID)
	var i CreateProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const createProductModel = `-- name: CreateProductModel :one
WITH inserted_model AS (
    INSERT INTO product.model (
        id, brand_id, name, description, list_price, date_manufactured
    ) VALUES (
        $1, $2, $3, $4, $5, $6
    ) RETURNING id, brand_id, name, description, list_price, date_manufactured
),
inserted_images AS (
    INSERT INTO product.image (product_model_id, url)
    SELECT $1, unnest($7::text[])
    RETURNING url
),
inserted_tags AS (
    INSERT INTO product.tag_on_product (product_model_id, tag_name)
    SELECT $1, unnest($8::text[])
    RETURNING tag_name
)
SELECT 
    m.id,
    m.brand_id,
    m.name,
    m.description,
    m.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM inserted_model m
LEFT JOIN inserted_images i ON true
LEFT JOIN inserted_tags t ON true
GROUP BY m.id
`

type CreateProductModelParams struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Column7          []string
	Column8          []string
}

type CreateProductModelRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) CreateProductModel(ctx context.Context, arg CreateProductModelParams) (CreateProductModelRow, error) {
	row := q.db.QueryRow(ctx, createProductModel,
		arg.ID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.ListPrice,
		arg.DateManufactured,
		arg.Column7,
		arg.Column8,
	)
	var i CreateProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.Images,
		&i.Tags,
	)
	return i, err
}

const createSale = `-- name: CreateSale :one
INSERT INTO product.sale (
    id,
    tag_name,
    product_model_id,
    date_started,
    date_ended,
    quantity,
    used,
    is_active,
    discount_percent,
    discount_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tag_name, product_model_id, date_started, date_ended, quantity, used, is_active, discount_percent, discount_price
`

type CreateSaleParams struct {
	ID              []byte
	TagName         pgtype.Text
	ProductModelID  []byte
	DateStarted     pgtype.Timestamp
	DateEnded       pgtype.Timestamp
	Quantity        int64
	Used            int64
	IsActive        bool
	DiscountPercent pgtype.Int4
	DiscountPrice   pgtype.Numeric
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (ProductSale, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.ID,
		arg.TagName,
		arg.ProductModelID,
		arg.DateStarted,
		arg.DateEnded,
		arg.Quantity,
		arg.Used,
		arg.IsActive,
		arg.DiscountPercent,
		arg.DiscountPrice,
	)
	var i ProductSale
	err := row.Scan(
		&i.ID,
		&i.TagName,
		&i.ProductModelID,
		&i.DateStarted,
		&i.DateEnded,
		&i.Quantity,
		&i.Used,
		&i.IsActive,
		&i.DiscountPercent,
		&i.DiscountPrice,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO product.tag (
    tag_name,
    description
) VALUES (
    $1, $2
) RETURNING tag_name, description
`

type CreateTagParams struct {
	TagName     string
	Description pgtype.Text
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (ProductTag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.TagName, arg.Description)
	var i ProductTag
	err := row.Scan(&i.TagName, &i.Description)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM product.brand WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteBrand, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM product.base WHERE serial_id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, serialID []byte) error {
	_, err := q.db.Exec(ctx, deleteProduct, serialID)
	return err
}

const deleteProductModel = `-- name: DeleteProductModel :exec
DELETE FROM product.model WHERE id = $1
`

func (q *Queries) DeleteProductModel(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteProductModel, id)
	return err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM product.sale WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id []byte) error {
	_, err := q.db.Exec(ctx, deleteSale, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM product.tag WHERE tag_name = $1
`

func (q *Queries) DeleteTag(ctx context.Context, tagName string) error {
	_, err := q.db.Exec(ctx, deleteTag, tagName)
	return err
}

const getBrand = `-- name: GetBrand :one
SELECT 
    b.id, b.name, b.description,
    COALESCE(array_agg(i.url) FILTER (WHERE i.url IS NOT NULL), '{}')::TEXT[] as images
FROM product.brand b
LEFT JOIN product.image i ON i.brand_id = b.id
WHERE b.id = $1
GROUP BY b.id
`

type GetBrandRow struct {
	ID          []byte
	Name        string
	Description string
	Images      []string
}

func (q *Queries) GetBrand(ctx context.Context, id []byte) (GetBrandRow, error) {
	row := q.db.QueryRow(ctx, getBrand, id)
	var i GetBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Images,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
FROM product.base
WHERE serial_id = $1
`

type GetProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) GetProduct(ctx context.Context, serialID []byte) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, serialID)
	var i GetProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const getProductModel = `-- name: GetProductModel :one
SELECT 
    pm.id, pm.brand_id, pm.name, pm.description, pm.list_price, pm.date_manufactured,
    COALESCE(array_agg(i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM product.model pm
LEFT JOIN product.image i ON i.product_model_id = pm.id
LEFT JOIN product.tag_on_product t ON t.product_model_id = pm.id
WHERE pm.id = $1
GROUP BY pm.id
`

type GetProductModelRow struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Images           interface{}
	Tags             interface{}
}

func (q *Queries) GetProductModel(ctx context.Context, id []byte) (GetProductModelRow, error) {
	row := q.db.QueryRow(ctx, getProductModel, id)
	var i GetProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.DateManufactured,
		&i.Images,
		&i.Tags,
	)
	return i, err
}

const listBrands = `-- name: ListBrands :many
WITH filtered_brands AS (
  SELECT
    b.id, b.name, b.description, 
    COALESCE(array_agg(i.url) FILTER (WHERE i.url IS NOT NULL), '{}')::TEXT[] as images
  FROM product.brand b
  INNER JOIN product.image i ON i.brand_id = b.id
  WHERE (
    (name ILIKE $3 OR $3 IS NULL) AND
    (description ILIKE $4 OR $4 IS NULL)
  )
  GROUP BY b.id
)
SELECT id, name, description, images
FROM filtered_brands
LIMIT $2
OFFSET $1
`

type ListBrandsParams struct {
	Offset      int32
	Limit       int32
	Name        pgtype.Text
	Description pgtype.Text
}

type ListBrandsRow struct {
	ID          []byte
	Name        string
	Description string
	Images      []string
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]ListBrandsRow, error) {
	rows, err := q.db.Query(ctx, listBrands,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.Description,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBrandsRow
	for rows.Next() {
		var i ListBrandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductModels = `-- name: ListProductModels :many
SELECT 
    pm.id, pm.brand_id, pm.name, pm.description, pm.list_price, pm.date_manufactured,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM product.model pm
LEFT JOIN product.image i ON i.product_model_id = pm.id
LEFT JOIN product.tag_on_product t ON t.product_model_id = pm.id
WHERE (
    (pm.brand_id = $1 OR $1 IS NULL) AND
    (pm.name ILIKE '%' || $2 || '%' OR $2 IS NULL) AND
    (pm.description ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
    (pm.list_price = $4 OR $4 IS NULL) AND 
    (pm.date_manufactured >= $5 OR $5 IS NULL) AND
    (pm.date_manufactured <= $6 OR $6 IS NULL)
)
GROUP BY pm.id
ORDER BY pm.id DESC
LIMIT $8
OFFSET $7
`

type ListProductModelsParams struct {
	BrandID              []byte
	Column2              pgtype.Text
	Column3              pgtype.Text
	ListPrice            pgtype.Numeric
	DateManufacturedFrom pgtype.Timestamp
	DateManufacturedTo   pgtype.Timestamp
	Offset               int32
	Limit                int32
}

type ListProductModelsRow struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Images           interface{}
	Tags             interface{}
}

func (q *Queries) ListProductModels(ctx context.Context, arg ListProductModelsParams) ([]ListProductModelsRow, error) {
	rows, err := q.db.Query(ctx, listProductModels,
		arg.BrandID,
		arg.Column2,
		arg.Column3,
		arg.ListPrice,
		arg.DateManufacturedFrom,
		arg.DateManufacturedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductModelsRow
	for rows.Next() {
		var i ListProductModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.Name,
			&i.Description,
			&i.ListPrice,
			&i.DateManufactured,
			&i.Images,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
FROM product.base
WHERE ($1::bytea IS NULL OR product_model_id = $1)
    AND ($2::timestamp IS NULL OR date_created >= $2)
    AND ($3::timestamp IS NULL OR date_created <= $3)
ORDER BY date_created DESC
LIMIT $4 OFFSET $5
`

type ListProductsParams struct {
	Column1 []byte
	Column2 pgtype.Timestamp
	Column3 pgtype.Timestamp
	Limit   int32
	Offset  int32
}

type ListProductsRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.SerialID,
			&i.ProductModelID,
			&i.DateCreated,
			&i.DateUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :exec
UPDATE product.brand
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
`

type UpdateBrandParams struct {
	ID          []byte
	Name        string
	Description string
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) error {
	_, err := q.db.Exec(ctx, updateBrand, arg.ID, arg.Name, arg.Description)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE product.base
SET 
    product_model_id = $2,
    date_update = NOW()
WHERE serial_id = $1
RETURNING 
    serial_id,
    product_model_id,
    EXTRACT(EPOCH FROM date_created)::bigint as date_created,
    EXTRACT(EPOCH FROM date_update)::bigint as date_update
`

type UpdateProductParams struct {
	SerialID       []byte
	ProductModelID []byte
}

type UpdateProductRow struct {
	SerialID       []byte
	ProductModelID []byte
	DateCreated    int64
	DateUpdate     int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (UpdateProductRow, error) {
	row := q.db.QueryRow(ctx, updateProduct, arg.SerialID, arg.ProductModelID)
	var i UpdateProductRow
	err := row.Scan(
		&i.SerialID,
		&i.ProductModelID,
		&i.DateCreated,
		&i.DateUpdate,
	)
	return i, err
}

const updateProductModel = `-- name: UpdateProductModel :one
WITH updated_model AS (
    UPDATE product.model
    SET brand_id = $2,
        name = $3,
        description = $4,
        list_price = $5,
        date_manufactured = $6
    WHERE id = $1
    RETURNING id, brand_id, name, description, list_price, date_manufactured
),
deleted_images AS (
    DELETE FROM product.image
    WHERE product_model_id = $1
),
deleted_tags AS (
    DELETE FROM product.tag_on_product
    WHERE product_model_id = $1
),
inserted_images AS (
    INSERT INTO product.image (product_model_id, url)
    SELECT $1, unnest($7::text[])
    RETURNING url
),
inserted_tags AS (
    INSERT INTO product.tag_on_product (product_model_id, tag_name)
    SELECT $1, unnest($8::text[])
    RETURNING tag_name
)
SELECT 
    m.id,
    m.brand_id,
    m.name,
    m.description,
    m.list_price,
    COALESCE(array_agg(DISTINCT i.url) FILTER (WHERE i.url IS NOT NULL), '{}') as images,
    COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') as tags
FROM updated_model m
LEFT JOIN inserted_images i ON true
LEFT JOIN inserted_tags t ON true
GROUP BY m.id
`

type UpdateProductModelParams struct {
	ID               []byte
	BrandID          []byte
	Name             string
	Description      string
	ListPrice        pgtype.Numeric
	DateManufactured pgtype.Timestamp
	Column7          []string
	Column8          []string
}

type UpdateProductModelRow struct {
	ID          []byte
	BrandID     []byte
	Name        string
	Description string
	ListPrice   pgtype.Numeric
	Images      interface{}
	Tags        interface{}
}

func (q *Queries) UpdateProductModel(ctx context.Context, arg UpdateProductModelParams) (UpdateProductModelRow, error) {
	row := q.db.QueryRow(ctx, updateProductModel,
		arg.ID,
		arg.BrandID,
		arg.Name,
		arg.Description,
		arg.ListPrice,
		arg.DateManufactured,
		arg.Column7,
		arg.Column8,
	)
	var i UpdateProductModelRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Name,
		&i.Description,
		&i.ListPrice,
		&i.Images,
		&i.Tags,
	)
	return i, err
}
