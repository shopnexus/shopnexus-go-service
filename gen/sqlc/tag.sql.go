// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tag.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM product.tag
WHERE
    ($1::text IS NULL OR tag ILIKE '%' || $1 || '%') AND
    ($2::text IS NULL OR description ILIKE '%' || $2 || '%')
`

type CountTagsParams struct {
	Tag         pgtype.Text
	Description pgtype.Text
}

func (q *Queries) CountTags(ctx context.Context, arg CountTagsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTags, arg.Tag, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO product.tag (
    tag,
    description
) VALUES (
    $1, $2
)
`

type CreateTagParams struct {
	Tag         string
	Description string
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.db.Exec(ctx, createTag, arg.Tag, arg.Description)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM product.tag WHERE tag = $1
`

func (q *Queries) DeleteTag(ctx context.Context, tag string) error {
	_, err := q.db.Exec(ctx, deleteTag, tag)
	return err
}

const getTag = `-- name: GetTag :one
SELECT tag, description FROM product.tag WHERE tag = $1
`

func (q *Queries) GetTag(ctx context.Context, tag string) (ProductTag, error) {
	row := q.db.QueryRow(ctx, getTag, tag)
	var i ProductTag
	err := row.Scan(&i.Tag, &i.Description)
	return i, err
}

const listTags = `-- name: ListTags :many
SELECT tag, description FROM product.tag
WHERE
    ($1::text IS NULL OR tag ILIKE '%' || $1 || '%') AND
    ($2::text IS NULL OR description ILIKE '%' || $2 || '%')
ORDER BY tag
LIMIT $4
OFFSET $3
`

type ListTagsParams struct {
	Tag         pgtype.Text
	Description pgtype.Text
	Offset      int32
	Limit       int32
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]ProductTag, error) {
	rows, err := q.db.Query(ctx, listTags,
		arg.Tag,
		arg.Description,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductTag
	for rows.Next() {
		var i ProductTag
		if err := rows.Scan(&i.Tag, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTag = `-- name: UpdateTag :exec
UPDATE product.tag
SET 
    tag = COALESCE($2, tag),
    description = COALESCE($3, description)
WHERE tag = $1
`

type UpdateTagParams struct {
	Tag         string
	NewTag      pgtype.Text
	Description pgtype.Text
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.db.Exec(ctx, updateTag, arg.Tag, arg.NewTag, arg.Description)
	return err
}
