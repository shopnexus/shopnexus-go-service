// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: brand.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBrands = `-- name: CountBrands :one
WITH filtered_brands AS (
  SELECT b.id
  FROM product.brand b
  WHERE (
    (name ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
    (description ILIKE '%' || $2 || '%' OR $2 IS NULL)
  )
)
SELECT COUNT(id)
FROM filtered_brands
`

type CountBrandsParams struct {
	Name        pgtype.Text
	Description pgtype.Text
}

func (q *Queries) CountBrands(ctx context.Context, arg CountBrandsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBrands, arg.Name, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrand = `-- name: CreateBrand :one
WITH inserted_brand AS (
    INSERT INTO product.brand (name, description)
    VALUES ($1, $2)
    RETURNING id, name, description
),
inserted_resources AS (
    INSERT INTO product.resource (owner_id, s3_id)
    SELECT id, unnest($3::text[]) FROM inserted_brand
    RETURNING s3_id
)
SELECT 
    b.id,
    COALESCE(array_agg(res.s3_id), '{}')::text[] as resources
FROM inserted_brand b
LEFT JOIN inserted_resources res ON true
GROUP BY b.id
`

type CreateBrandParams struct {
	Name        string
	Description string
	Resources   []string
}

type CreateBrandRow struct {
	ID        int64
	Resources []string
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (CreateBrandRow, error) {
	row := q.db.QueryRow(ctx, createBrand, arg.Name, arg.Description, arg.Resources)
	var i CreateBrandRow
	err := row.Scan(&i.ID, &i.Resources)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM product.brand WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBrand, id)
	return err
}

const getBrand = `-- name: GetBrand :one
SELECT 
    b.id, b.name, b.description,
    COALESCE(array_agg(i.s3_id) FILTER (WHERE i.s3_id IS NOT NULL), '{}')::TEXT[] as resources
FROM product.brand b
LEFT JOIN product.resource i ON i.owner_id = b.id
WHERE b.id = $1
GROUP BY b.id
`

type GetBrandRow struct {
	ID          int64
	Name        string
	Description string
	Resources   []string
}

func (q *Queries) GetBrand(ctx context.Context, id int64) (GetBrandRow, error) {
	row := q.db.QueryRow(ctx, getBrand, id)
	var i GetBrandRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Resources,
	)
	return i, err
}

const listBrands = `-- name: ListBrands :many
WITH filtered_brands AS (
  SELECT
    b.id, b.name, b.description, 
    COALESCE(array_agg(i.s3_id) FILTER (WHERE i.s3_id IS NOT NULL), '{}')::TEXT[] as resources
  FROM product.brand b
  INNER JOIN product.resource i ON i.owner_id = b.id
  WHERE (
    (name ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
    (description ILIKE '%' || $4 || '%' OR $4 IS NULL)
  )
  GROUP BY b.id
)
SELECT id, name, description, resources
FROM filtered_brands
LIMIT $2
OFFSET $1
`

type ListBrandsParams struct {
	Offset      int32
	Limit       int32
	Name        pgtype.Text
	Description pgtype.Text
}

type ListBrandsRow struct {
	ID          int64
	Name        string
	Description string
	Resources   []string
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]ListBrandsRow, error) {
	rows, err := q.db.Query(ctx, listBrands,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.Description,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBrandsRow
	for rows.Next() {
		var i ListBrandsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Resources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :exec
UPDATE product.brand
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
`

type UpdateBrandParams struct {
	ID          int64
	Name        pgtype.Text
	Description pgtype.Text
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) error {
	_, err := q.db.Exec(ctx, updateBrand, arg.ID, arg.Name, arg.Description)
	return err
}
